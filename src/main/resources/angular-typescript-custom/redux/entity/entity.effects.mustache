import { inject, Injectable } from '@angular/core';
import { Actions, createEffect, ofType } from '@ngrx/effects';
import { catchError, EMPTY, map, mergeMap, of, switchMap } from 'rxjs';
import { {{entityName}}Service } from '@api/{{#lambda.KebabCustom}}{{apiName}}{{/lambda.KebabCustom}}/services/{{#lambda.KebabCustom}}{{{entityName}}}{{/lambda.KebabCustom}}.service';
import { {{entityName}}Actions } from './{{#lambda.KebabCustom}}{{{entityName}}}{{/lambda.KebabCustom}}.actions';
{{#operations}}
{{#operation}}
import { select{{#lambda.pascalcase}}{{operationIdOriginal}}{{/lambda.pascalcase}}Form } from './{{#lambda.KebabCustom}}{{entityName}}{{/lambda.KebabCustom}}.selector';
{{/operation}}
{{/operations}}
{{#operations}}
{{#operation}}
import { {{{operationIdOriginal}}}Request } from '@api/{{#lambda.KebabCustom}}{{apiName}}{{/lambda.KebabCustom}}/services/{{#lambda.KebabCustom}}{{classname}}{{/lambda.KebabCustom}}.service'; 
{{/operation}}
{{/operations}}
import { Store } from '@ngrx/store';
import { withLatestFrom } from 'rxjs';
import { ValidationErrors } from '@angular/forms';
import { ValidationError } from '@api/{{#lambda.KebabCustom}}{{apiName}}{{/lambda.KebabCustom}}/models/validation-error.model';
import { HttpErrorResponse } from '@angular/common/http';

const toValidationErrors = (errors: ValidationError[]): ValidationErrors => {
  return errors.reduce((acc, err) => {
    acc[err.property] = err.message;
    return acc;
  }, {} as ValidationErrors);
};

@Injectable(
    
)
export class {{entityName}}Effects {
    private actions$ = inject(Actions);
    private api = inject({{{entityName}}}Service);
    private store = inject(Store);

    Init$ = createEffect(() =>
    this.actions$.pipe(
        ofType({{entityName}}Actions.Init),
        mergeMap(() => [
            {{#operations}}
            {{#operation}}
                {{entityName}}Actions.{{{operationIdOriginal}}}Init(),
            {{/operation}}
            {{/operations}}
        ])
    ));

    {{#operations}}
    {{#operation}}
    {{{operationIdOriginal}}}Execute$ = createEffect(() =>
    this.actions$.pipe(
        ofType({{entityName}}Actions.{{{operationIdOriginal}}}Execute),
        withLatestFrom(this.store.select(select{{#lambda.pascalcase}}{{operationIdOriginal}}{{/lambda.pascalcase}}Form)),
        switchMap(([action, form]) =>
            this.api.{{{operationIdOriginal}}}(form.value as {{operationIdOriginal}}Request, 'response').pipe(
                //@ts-ignore
                {{#lambda.Skip}}map(response => {{entityName}}Actions.{{{operationIdOriginal}}}SetData({data: {{#isArray}}{items: response.body!.data, currentPage: Number(response.headers.get('X-Current-Page')),totalPages: Number(response.headers.get('X-Total-Pages')),pageSize: Number(response.headers.get('X-Page-Size')),totalCount: Number(response.headers.get('X-Total-Count'))}{{/isArray}}{{^isArray}}response.body!.data{{/isArray}}  })),{{/lambda.Skip}}
                {{#lambda.Add}}map(() => {{entityName}}Actions.{{{operationIdOriginal}}}Success()),{{/lambda.Add}}
                catchError((err, caught) => {
                    const newErr = err as HttpErrorResponse;
                    if(newErr.status == 400){
                        if(newErr.error){
                            const newErrors = newErr.error as ValidationError[];
                            form.setErrors(toValidationErrors(newErrors));
                            //@ts-ignore
                            return of({{entityName}}Actions.{{{operationIdOriginal}}}SetError({form}))
                        }
                    }
                    return EMPTY;
                })
        )))
    );
    {{/operation}}
    {{/operations}}
}
