import { inject, Injectable } from '@angular/core';
import { Actions, createEffect, ofType } from '@ngrx/effects';
import { catchError, EMPTY, map, mergeMap, of, switchMap, withLatestFrom, pairwise, filter, debounceTime } from 'rxjs';
import { {{entityName}}Service } from '@api/{{#lambda.KebabCustom}}{{apiName}}{{/lambda.KebabCustom}}/services/{{#lambda.KebabCustom}}{{{entityName}}}{{/lambda.KebabCustom}}.service';
import { {{entityName}}Actions } from './{{#lambda.KebabCustom}}{{{entityName}}}{{/lambda.KebabCustom}}.actions';
{{#operations}}
{{#operation}}
import { select{{#lambda.pascalcase}}{{operationIdOriginal}}{{/lambda.pascalcase}}Request } from './{{#lambda.KebabCustom}}{{entityName}}{{/lambda.KebabCustom}}.selector';
{{/operation}}
{{/operations}}
{{#operations}}
{{#operation}}
import { {{{operationIdOriginal}}}Request } from '@api/{{#lambda.KebabCustom}}{{apiName}}{{/lambda.KebabCustom}}/services/{{#lambda.KebabCustom}}{{classname}}{{/lambda.KebabCustom}}.service'; 
{{/operation}}
{{/operations}}
import { Store } from '@ngrx/store';
import { ValidationErrors } from '@angular/forms';
import { ValidationError } from '@api/{{#lambda.KebabCustom}}{{apiName}}{{/lambda.KebabCustom}}/models/validation-error.model';
import { HttpErrorResponse } from '@angular/common/http';

@Injectable(
    
)
export class {{entityName}}Effects {
    private actions$ = inject(Actions);
    private api = inject({{{entityName}}}Service);
    private store = inject(Store);

    Init$ = createEffect(() =>
    this.actions$.pipe(
        ofType({{entityName}}Actions.Init),
        mergeMap(() => [
            {{#operations}}
            {{#operation}}
                {{entityName}}Actions.{{{operationIdOriginal}}}Init(),
            {{/operation}}
            {{/operations}}
        ])
    ));

    {{#operations}}
    {{#operation}}
    {{#lambda.UsePage}}
    {{=<% %>=}}
    <% returnType %>
    <% operationIdOriginal %>ChangePage$ = createEffect(() =>
        this.actions$.pipe(
            ofType(<% entityName %>Actions.<% operationIdOriginal %>ChangePage),
            map(({ event }) => ({
                pageSize: event.pageSize,
                currentPage: event.pageIndex + 1
            })),
            map(request =>
                //@ts-ignore
                <% entityName %>Actions.<% operationIdOriginal %>RequestUpdate({ request })
            )
        )
    );
    <%={{ }}=%>
    {{/lambda.UsePage}}
    {{{operationIdOriginal}}}UpdateRequest$ = createEffect(() =>
        this.actions$.pipe(
            ofType({{entityName}}Actions.{{{operationIdOriginal}}}RequestUpdate),
            debounceTime(300),
            map(action => action.request),
            pairwise<{{{operationIdOriginal}}}Request>(),
            map(([prev, curr]) => {
                const changedKeys = (Object.keys(curr) as (keyof {{{operationIdOriginal}}}Request)[])
                    .filter(k => prev[k] !== curr[k]);

                if (changedKeys.length === 0) {
                    return [prev, false] as const;
                }

                const updated = { ...prev };
                changedKeys.forEach(k => {
                    //@ts-ignore
                    updated[k] = curr[k];
                });

                return [updated, true] as const;
            }),
            filter(([_, status]) => status),
            map(([request]) =>
                {{entityName}}Actions.{{{operationIdOriginal}}}RequestUpdateSuccess({ request })
            )
        )
    );
    {{{operationIdOriginal}}}UpdateOneRequest$ = createEffect(() =>
    this.actions$.pipe(
        ofType({{entityName}}Actions.{{{operationIdOriginal}}}RequestUpdateOne),
        debounceTime(300),
        map(action => action.request),
        pairwise<{{{operationIdOriginal}}}Request>(),
        map(([prev, curr]) => {
        const key = (Object.keys(curr) as (keyof {{{operationIdOriginal}}}Request)[])
            .find(k => prev[k] !== curr[k]);
            return key ? [key, curr[key]] : [null, null];
        }),
        filter((pair): pair is [keyof {{{operationIdOriginal}}}Request, any] => pair[0] !== null),
        map(([key,value]) =>
            {{entityName}}Actions.{{{operationIdOriginal}}}RequestUpdateOneSuccess({ key,value })
        )
    ));
    {{{operationIdOriginal}}}Execute$ = createEffect(() =>
    this.actions$.pipe(
        ofType({{entityName}}Actions.{{{operationIdOriginal}}}Execute),
        withLatestFrom(this.store.select(select{{#lambda.pascalcase}}{{operationIdOriginal}}{{/lambda.pascalcase}}Request)),
        switchMap(([action, request]) =>
            this.api.{{{operationIdOriginal}}}(request as {{operationIdOriginal}}Request, 'response').pipe(
                //@ts-ignore
                {{#lambda.Skip}}map(response => {{entityName}}Actions.{{{operationIdOriginal}}}SetData({data: {{#isArray}}{items: response.body!.data, currentPage: Number(response.headers.get('X-Current-Page')),totalPages: Number(response.headers.get('X-Total-Pages')),pageSize: Number(response.headers.get('X-Page-Size')),totalCount: Number(response.headers.get('X-Total-Count'))}{{/isArray}}{{^isArray}}response.body!.data{{/isArray}}  })),{{/lambda.Skip}}
                {{#lambda.Add}}map(() => {{entityName}}Actions.{{{operationIdOriginal}}}Success()),{{/lambda.Add}}
                catchError((err, caught) => {
                    const newErr = err as HttpErrorResponse;
                    if(newErr.status == 400){
                        if(newErr.error){
                            const newErrors = newErr.error as ValidationError[];
                            // @ts-ignore
                            return of({{entityName}}Actions.{{{operationIdOriginal}}}SetError({errors: newErrors}))
                        }
                    }{{#lambda.Skip}}else if(newErr.status == 404){return of(ClientesActions.{{{operationIdOriginal}}}DataInit()); }{{/lambda.Skip}}
                    return EMPTY;
                })
        )))
    );
    {{/operation}}
    {{/operations}}
}
