import { inject, Injectable } from '@angular/core';
import { Actions, createEffect, ofType } from '@ngrx/effects';
import { catchError, EMPTY, map, mergeMap, of, switchMap, withLatestFrom, pairwise, filter, debounceTime } from 'rxjs';
import { {{entityName}}Service } from '@api/{{#lambda.KebabCustom}}{{apiName}}{{/lambda.KebabCustom}}/services/{{#lambda.KebabCustom}}{{{entityName}}}{{/lambda.KebabCustom}}.service';
import { {{entityName}}Actions } from './{{#lambda.KebabCustom}}{{{entityName}}}{{/lambda.KebabCustom}}.actions';
{{#operations}}
{{#operation}}
import { select{{#lambda.pascalcase}}{{operationIdOriginal}}{{/lambda.pascalcase}}Request } from './{{#lambda.KebabCustom}}{{entityName}}{{/lambda.KebabCustom}}.selector';
import { select{{#lambda.pascalcase}}{{operationIdOriginal}}{{/lambda.pascalcase}}FirstInit } from './{{#lambda.KebabCustom}}{{entityName}}{{/lambda.KebabCustom}}.selector';
{{/operation}}
{{/operations}}
{{#operations}}
{{#operation}}
import { {{{operationIdOriginal}}}Request } from '@api/{{#lambda.KebabCustom}}{{apiName}}{{/lambda.KebabCustom}}/services/{{#lambda.KebabCustom}}{{classname}}{{/lambda.KebabCustom}}.service'; 
{{/operation}}
{{/operations}}
import { Store } from '@ngrx/store';
import { ValidationErrors } from '@angular/forms';
import { ValidationError } from '@api/{{#lambda.KebabCustom}}{{apiName}}{{/lambda.KebabCustom}}/models/validation-error.model';
import { HttpErrorResponse } from '@angular/common/http';
import {SnackbarService} from '@features/snackbar/snackbar-service'; 

@Injectable(
    
)
export class {{entityName}}Effects {
    private actions$ = inject(Actions);
    private api = inject({{{entityName}}}Service);
    private store = inject(Store);
    private snackbarService = inject(SnackbarService);

    Init$ = createEffect(() =>
    this.actions$.pipe(
        ofType({{entityName}}Actions.Init),
        mergeMap(() => [
            {{#operations}}
            {{#operation}}
                {{entityName}}Actions.{{{operationIdOriginal}}}Init(),
            {{/operation}}
            {{/operations}}
        ])
    ));

    {{#operations}}
    {{#operation}}
    {{#lambda.UsePage}}
    {{=<% %>=}}
    <% returnType %>
    <% operationIdOriginal %>ChangePage$ = createEffect(() =>
        this.actions$.pipe(
            ofType(<% entityName %>Actions.<% operationIdOriginal %>ChangePage),
            map(({ event }) => ({
                pageSize: event.pageSize,
                currentPage: event.pageIndex + 1
            })),
            map(request =>
                //@ts-ignore
                <% entityName %>Actions.<% operationIdOriginal %>RequestUpdate({ request })
            )
        )
    );
    <%={{ }}=%>
    {{/lambda.UsePage}}
    {{{operationIdOriginal}}}UpdateRequest$ = createEffect(() =>
    this.actions$.pipe(
        ofType({{entityName}}Actions.{{{operationIdOriginal}}}RequestUpdate),
        debounceTime(300),
        withLatestFrom(
            this.store.select(select{{#lambda.pascalcase}}{{{operationIdOriginal}}}{{/lambda.pascalcase}}FirstInit),
            this.store.select(select{{#lambda.pascalcase}}{{{operationIdOriginal}}}{{/lambda.pascalcase}}Request)
        ),
        map(([action, firstInit, prevRequest]) => ({
            request: action.request,
            skip: firstInit,
            prevRequest
        })),
        map(({request, skip, prevRequest}) => {
        if (skip || request == null) {
            return [prevRequest, false] as const;
        }
        if(prevRequest == null) prevRequest = new {{{operationIdOriginal}}}Request();
        const changedKeys = (Object.keys(request) as (keyof {{{operationIdOriginal}}}Request)[])
            .filter(k => prevRequest[k] !== request[k]);

        if (changedKeys.length === 0) {
            return [prevRequest, false] as const;
        }

        const updated = { ...prevRequest };
        changedKeys.forEach(k => {
            //@ts-ignore
            updated[k] = request[k];
        });
        return [updated, true] as const;
        }),
        filter(([_, status]) => status),
        // @ts-ignore
        map(([request]) => {
            // @ts-ignore
            const nRequest = new {{{operationIdOriginal}}}Request();
            // @ts-ignore
            Object.assign(nRequest,request);
            // @ts-ignore
            return {{entityName}}Actions.{{{operationIdOriginal}}}RequestUpdateSuccess({ request: nRequest });
        })
    )
    );
    {{{operationIdOriginal}}}UpdateOneRequest$ = createEffect(() =>
        this.actions$.pipe(
            ofType({{entityName}}Actions.{{{operationIdOriginal}}}RequestUpdateOne),
            debounceTime(300),
            withLatestFrom(
                this.store.select(select{{#lambda.pascalcase}}{{{operationIdOriginal}}}{{/lambda.pascalcase}}FirstInit),
                this.store.select(select{{#lambda.pascalcase}}{{{operationIdOriginal}}}{{/lambda.pascalcase}}Request)
            ),
            map(([action, firstInit, prevRequest]) => ({
                request: action.request,
                skip: firstInit,
                prevRequest
            })),
            map(({request,skip,prevRequest}) => {
            if (skip || request == null) {
                return [null, null] as const;
            }
            if(prevRequest == null) prevRequest = new {{{operationIdOriginal}}}Request();
            const key = (Object.keys(request) as (keyof {{{operationIdOriginal}}}Request)[])
                .find(k => prevRequest[k] !== request[k]);

            return key ? [key, request[key]] : [null, null] as const;
            }),
            filter((pair): pair is [keyof {{{operationIdOriginal}}}Request, any] => pair[0] !== null),
            map(([key, value]) =>
                {{entityName}}Actions.{{{operationIdOriginal}}}RequestUpdateOneSuccess({ key, value })
            )
        )
        );
        {{{operationIdOriginal}}}Execute$ = createEffect(() =>
        this.actions$.pipe(
            ofType({{entityName}}Actions.{{{operationIdOriginal}}}Execute),
            withLatestFrom(
                this.store.select(select{{#lambda.pascalcase}}{{operationIdOriginal}}{{/lambda.pascalcase}}Request),
                this.store.select(select{{#lambda.pascalcase}}{{{operationIdOriginal}}}{{/lambda.pascalcase}}FirstInit)
            ),
            switchMap(([action, request, firstInit]) => {
            if (firstInit {{#lambda.OnlyFilter}} || request == null {{/lambda.OnlyFilter}}) {
                return EMPTY; 
            }
            // @ts-ignore
            return this.api.{{{operationIdOriginal}}}(request as {{operationIdOriginal}}Request, 'response').pipe(
                {{#lambda.Skip}}
                map(response =>{
                    {{#lambda.ShowMessage}} {{{operationIdOriginal}}} this.snackbarService.show(response.body!.message, response.body!.statusCode);{{/lambda.ShowMessage}}
                    return {{entityName}}Actions.{{{operationIdOriginal}}}SetData({
                        data: {{#isArray}}
                        {
                            //@ts-ignore
                            items: response.body!.data,
                            currentPage: Number(response.headers.get('X-Current-Page')),
                            totalPages: Number(response.headers.get('X-Total-Pages')),
                            pageSize: Number(response.headers.get('X-Page-Size')),
                            totalCount: Number(response.headers.get('X-Total-Count'))
                        }
                        {{/isArray}}
                        {{^isArray}}
                        response.body!.data
                        {{/isArray}}
                    })
                }),
                {{/lambda.Skip}}
                {{#lambda.Add}}map(() => {{entityName}}Actions.{{{operationIdOriginal}}}Success()),{{/lambda.Add}}
                catchError((err) => {
                const newErr = err as HttpErrorResponse;
                if (newErr.status === 400 && newErr.error) {
                    const newErrors = newErr.error!.data as ValidationError[][];
                    {{#lambda.ShowMessage}} {{{operationIdOriginal}}} this.snackbarService.show(newErr.error!.message, newErr.error!.statusCode);{{/lambda.ShowMessage}}
                    //@ts-ignore
                    return of({{entityName}}Actions.{{{operationIdOriginal}}}SetError({ errors: newErrors!.data }));
                }
                {{#lambda.Skip}}
                else if (newErr.status === 404) {
                    return of({{entityName}}Actions.{{{operationIdOriginal}}}DataInit());
                }
                {{/lambda.Skip}}
                return EMPTY;
                })
            );
            })
        )
        );

    {{/operation}}
    {{/operations}}
}
